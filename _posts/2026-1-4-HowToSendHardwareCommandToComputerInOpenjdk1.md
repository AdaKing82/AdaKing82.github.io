---
layout:     post
title:      How to send hardware command to computer in openjdk (1) -- Assembly instruction and encoding basis
subtitle:   basic knowledge of assembly language
date:       2026-1-4
author:     Brother King
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - JVM
---
# How to send hardware command to computer in openjdk (1) -- Assembly instruction and encoding basis

## What is assembly instruction?
In the excution of computer circuit, the computer itself only recognises the 0 or 1 digital signal. To enable the CPU processes the logical successfully, the instructions sending to the computer must be compromised with only 0 and 1.

For example,  **push**ing the value from rbx register into the memory stack is `01010011` , which is in the form of binary code. 

However, it is really difficult for programmers to write codes by binary form. But programmers in the early age indeed did it in this unbelievable way. Obviously, writting binary code brings two main problems.

1. Prone to error
2. Inconvienet to remember what the instructions

For avoiding the mistakes that may happen above, manufatures often define a serial of English keywords to represent instructions. These English keywords is called **Assembly Instructions** or **Assembly language**.

For instance, the pushing instruction previously described is below.

```assembly
push %rbx
```
If the codes, `push %rbx`, is written to the .s file and compiled by compiler, like gcc, the corresponding  object file will be generated, and the position, which stands for `push %rbx`, will be replaced by the number `0x53`, which is the hex-decimal form of `01010011`

If the CPU gets the `0x53`, it will definitely push the value of rbx to the stack.

In conclusion, `push %rbx` , a literal, must be converted to a unique binary code that CPU can recognize and be executed.

## Instruction encoding

The instruction is made by 2 parts. The first one is called mnemonic, the others are operands. Compilers will translate the instruction written by English to binary codes accoriding to specific rules. No matter what the compilers do, the final consequence  is a set of binary codes that can be recognized and run by CPU.

Each maufacture has its own encoding rules due to the differences in their sets(CISC: Complex Instruction Set; RISC: Reduced Instruction Set).

According to the manual of x64, the `push %rbx` coding rule is below.

![alt text](https://cdn.jsdelivr.net/gh/adaking82/AdaKing82.github.io/images/2026-1-4/push.png)

`push` represents `0x50`

`reg64` is replaced by `%rbx`, and the number of register rbx is encoding 3. Therefore, the result of `0x50 + 0x3` is `0x53`.

## The compiling rule
For the description above, we can find that the binary codes are generated by compilers relying on the compiling rules. First of all,  the compiler should make sure the value of mnemonic, which is specially called `opcode`. Followed by the operands encoding. Different CPU manufacturers has its own encoding rules.

Taking an adding instruction as an example, if the operation is adding two values from registers and puts the result into the destination register, the encoding rule of x64 is below.

![](https://cdn.jsdelivr.net/gh/adaking82/AdaKing82.github.io/images/2026-1-4/add_x64.png)

Assuming an instruction

```assembly
add %rbx, %rax
```

The machine code (or I can say binary code) is below

```bash
48 01 D8
```
The rule can be seen from the table below.

| Byte(s) | Meaning                                                      |
| ------- | ------------------------------------------------------------ |
| 48      | `REX prefix: 64-bit operand size (REX.W = 1)`                |
| 01      | `Opcode: ADD r/m64, r64 (adds second register to the first)` |
| D8      | `ModR/M byte: specifies registers â†’ rbx to rax`              |

Comparatively, the `AArch64` is an evolved architecutre of `ARM v8`. The instruction set belongs to `RISC`. Almost all embedded systems, like ARM, Apple and etc, adopt this ISA( Instruction Set Architecture). The equivalent adding operation is below. 

```assembly
add x0, x1, x2
```
the instruction above means calculating the sum of the value from register x1 and x2 and putting the result to the x0 register

the encoding rule from `AArch64` manual is below.

![](https://cdn.jsdelivr.net/gh/adaking82/AdaKing82.github.io/images/2026-1-4/add_aarch64_encoding.png)

Accoriding to the manual, if the instruction is run on the 64-bit platform, like Apple M2, the 31st is 1, Rm is x2, Rn is x1, which means the value at these positions are 2, 1 and 0. Other bits value is set by the rule, `imm6` is used for another operation, which is defaultly assigned 0.

Therefore, the machin code is below
```
#binary
10001011000 00010 000000 00001 00000

#hex-decimal
0x8B020020
#little encoding should read invertly
0x2000028B
```